import React from "react";

import step0 from "/src/assets/dynamic-programming-1/step-0.png";
import step1 from "/src/assets/dynamic-programming-1/step-1.png";
import step2 from "/src/assets/dynamic-programming-1/step-2.png";
import step2Wrong from "/src/assets/dynamic-programming-1/step-2-wrong.png";
import step3 from "/src/assets/dynamic-programming-1/step-3.png";

const TableData = ({ children, last, lastRow }) => (
  <td
    style={{
      backgroundColor: last && lastRow ? "green" : "#2f2f2f",
      padding: "8px",
      border: "1px solid white",
    }}
  >
    {children}
  </td>
);

const TableRow = ({ row, lastRow }) => (
  <tr style={{ backgroundColor: "#2f2f2f", color: "#e0e0e0" }}>
    {row.map((item, itemIndex) => {
      return (
        <TableData
          key={itemIndex}
          last={row.length - 1 === itemIndex}
          lastRow={lastRow}
        >
          {item}
        </TableData>
      );
    })}
  </tr>
);

const TableHead = ({ data }) => (
  <thead style={{ background: "tomato" }}>
    <tr>
      {data[0].map((_, index) => (
        <th key={index} style={{ padding: "8px" }}>
          {index + 1} MB
        </th>
      ))}
    </tr>
  </thead>
);

const Table = ({ data }) => {
  return (
    <table style={{ textAlign: "center", borderSpacing: "10px" }}>
      <caption>Пример таблицы с данными</caption>
      <TableHead data={data} />
      <tbody>
        {data.map((row, index) => (
          <TableRow row={row} key={index} lastRow={data.length - 1 === index} />
        ))}
      </tbody>
    </table>
  );
};

const DynamicProgramming1 = () => {
  // Напишем нашу функцию для оптимизации, принимающую массив размеров частей и размер пачки
  const prioritize = (filePartSizes, chunkSize) => {
    const table = Array(filePartSizes.length).fill(Array(chunkSize).fill(0));

    const result = table[filePartSizes.length - 1][chunkSize - 1];
    return table;
  };

  prioritize([4, 5, 7], 10);

  return (
    <div>
      <Table data={prioritize([4, 5, 7], 10)} />
      <h1>Задача о рюкзаке</h1>
      <p>
        Напомним условия нашей задачи. Предположим, вы разрабатываете
        веб-приложение для загрузки файлов — этакий менеджер загрузок из
        прошлого. Но из-за ограничений на стороне сервера можете получать данные
        только пачками по несколько мегабайт в зависимости от местоположения
        сервера (притом в одной пачке могут лежать части разных файлов). И уже
        на фронте вы склеиваете их в нормальные файлы. Всё усложняется тем, что
        все файлы заранее разбиты на части разных размеров. То есть какие-то из
        них могут быть с частями по 7 МБ, какие-то — по 4 МБ, какие-то — по 5
        МБ... Задача состоит в том, чтобы добавить в каждую пачку с сервера
        столько частей разных файлов, чтобы использовать максимальное количество
        места из доступного для пачки из 10 МБ.
      </p>
      <p>
        Давайте с новыми знаниями вернёмся к старой задаче и попробуем решить её
        оптимально. Как мы узнали из предыдущей статьи, нам нужно попытаться
        свести задачу к подзадачам, которые связаны между собой. В нашем случае
        стоит начать решать задачу для меньших пачек данных. А затем, используя
        их решения, получить решение исходной задачи.
      </p>
      <p>
        Составим таблицу из всех возможных частей файлов и всех возможных
        размеров пачки меньше 10 МБ с шагом в один мегабайт:
      </p>
      <img src={step0} alt="banners" width="100%" />
      <p>
        Теперь начнём заполнять таблицу сверху вниз. Сначала попробуем заполнить
        строку принятия решений «класть нам часть из 4 МБ или нет». В каждую
        ячейку будем записывать общий размер получающейся пачки и то, какие
        части файлов туда пойдут. Заполнить эту строчку довольно просто. В пачки
        до 4 МБ мы ничего не можем положить. В пачку от 4 МБ до 8 МБ положим
        одну часть. В более объёмные — две.
      </p>
      <img src={step1} alt="banners" width="100%" />
      <p>
        На этом этапе важно помнить, что сейчас мы решаем задачу только для
        частей одного размера, а трогать части из других строк пока не можем.
        Сейчас мы заняты решением подзадачи, которое будем переиспользовать в
        других подзадачах для частей большего размера.
      </p>
      <p>
        Начнём заполнять вторую строчку. Можно предположить, что она заполнится
        так же, как и в первый раз:
      </p>
      <img src={step2Wrong} alt="banners" width="100%" />
      <p>
        Но уже здесь мы видим неоптимальность. В 4 МБ всё ещё может поместиться
        одна часть по 4 МБ, в 8 МБ — две части. А вот в 9 МБ мы уже можем
        добавить части двух разных размеров и использовать все 9 МБ. Это
        обеспечит нам максимальную утилизацию пространства. Давайте обновим
        максимумы в нашей таблице с учётом решения предыдущей подзадачи!
      </p>
      <img src={step2} alt="banners" width="100%" />
      <p>По такому же принципу заполним и третью строку:</p>
      <img src={step3} alt="banners" width="100%" />
      <p>
        Теперь в нижней правой ячейке таблицы и есть решение нашей задачи! Это
        переиспользованное решение подзадачи с двумя предыдущими доступными
        частями.
      </p>
      <p>
        Самое время формализировать алгоритм заполнения этой таблицы, ведь до
        этого момента мы пользовались лишь здравым смыслом. Алгоритм довольно
        простой: в каждую ячейку идёт максимум из двух значений. Первое — это
        максимум решения предыдущей задачи (то, что находится ровно над
        заполняемой ячейкой), если он есть. А второе — размер максимального
        количества частей, помещающихся в этот размер + максимум решения
        предыдущей задачи для оставшегося места, если он есть.
      </p>
      <p>
        Например, когда мы заполняли решение задачи для частей двух разных
        размеров и пачки в 9 МБ, мы посчитали максимальное количество места,
        которое можем занять частями этого размера (получилась одна часть в 5
        мегабайт). И у нас осталось ещё 4 МБ, которые мы можем заполнить.
        Поэтому мы пошли в предыдущий столбец и посмотрели, чем мы можем
        заполнить их: одной частью в 4 МБ. Всего получилось 9 МБ. Ещё мы взяли
        максимум решения предыдущей подзадачи, 8 МБ, и максимум из двух
        получившихся чисел — 9. Это и пошло в нашу максимальную оценку для этой
        подзадачи.
      </p>
      <p>
        Эта таблица будет давать тот же ответ, если мы поменяем строчки местами
        или добавим части новых размеров. Можете построить подобные таблицы с
        новыми правилами вручную, чтобы убедиться в этом.
      </p>
    </div>
  );
};

export { DynamicProgramming1 };
